//! **Start here!** Finished noise functions built using
//! the primitive noise blocks.
//!
//! Just create the noise type you need and start using it! If you have
//! to make adjustments you can extend the returned values using `UnboxNoise::new`
//! and then combine it with all building blocks available. (This is subject to
//! change, once `-> impl ...` return types have landed in Rust.)
//!
//! Take a look at the source of this module if you want to build
//! your own noise functions.

use noise::Noise;
use input_op::InputOp;
use output_op::OutputOp;
use interpolated_noise::{InterpolatedNoise, InterpolatedNoise2D};
use interpolate::{Interpolator, PerlinInterpolator};
use default_noise::DefaultI32Noise;
use combined_noise::CombinedNoise;
use std::num::Float;

/// Generates value-interpolated one-dimensional continuous noise.
///
/// # Parameters
///
/// * `seed` is the seed used for the underlying random number generator.
/// * `amp` is the amplitude of the resulting noise (values will be from `-amp` to `+amp`).
/// * `freq` is the frequency of the noise.
/// * `interpolator` is the interpolator that will be used to interpolate.
pub fn new_noise_1d_int<'a, I: Interpolator<f64> + 'a>(seed: i32, amp: f64, freq: f64, interpolator: I)
        -> Box<Noise<f64, Out=f64> + 'a> {  // TODO use impl Noise<...>
    Box::new(
        OutputOp::new(
            InputOp::new(
                InterpolatedNoise::new(
                    DefaultI32Noise::new(seed),
                    interpolator
                ),
                move |p: f64| { p * freq }
            ),
            move |f: f64| { f * amp }
        )
    )
}

/// Generates smooth (value-interpolated) one-dimensional continuous noise.
///
/// # Parameters
///
/// * `seed` is the seed used for the underlying random number generator.
/// * `amp` is the amplitude of the resulting noise (values will be from `-amp` to `+amp`).
/// * `freq` is the frequency of the noise.
pub fn new_noise_1d(seed: i32, amp: f64, freq: f64) -> Box<Noise<f64, Out=f64> + 'static> {  // TODO use impl
	new_noise_1d_int(seed, amp, freq, PerlinInterpolator)
}

/// Generates two-dimensional continuous gradient noise.
///
/// # Parameters
///
/// * `seed` is used to seed the underlying random number generator.
/// * `amp` is the amplitude of the resulting noise (values from `-amp` to `+amp`).
/// * `freq_x` and `freq_y` is the requency of the noise.
/// * `interpolator` is the interpolator to be used.
// TODO use impl
pub fn new_noise_2d_ex
        <'a, I: Interpolator<f64> + 'a>
        (seed: i32, amp: f64, (freq_x, freq_y): (f64, f64), interpolator: I)
        -> Box<Noise<(f64, f64), Out=f64> + 'a> {
    Box::new(
        OutputOp::new(
            InputOp::new(
                InterpolatedNoise2D::new(
                    DefaultI32Noise::new(seed),
                    interpolator
                ),
                move |(x, y): (f64, f64)| { (x * freq_x, y * freq_y) }
            ),
            move |f: f64| { f * amp }
        )
    )
}

/// Generates two dimensional gradient noise using sensible defaults.
// TODO use impl
pub fn new_noise_2d(seed: i32, amp: f64, freq: f64) -> Box<Noise<(f64, f64), Out=f64> + 'static> {
    new_noise_2d_ex(seed, amp, (freq, freq), PerlinInterpolator)
}

/// Generates coherent one-dimensional so called Perlin Noise.
///
/// This noise is generated by adding `noise_1d(amp, freq)`,
/// `noise_1d(amp / 2, freq * 2)`, `noise_1d(amp / 4, freq * 4)`
/// and so on (octaves many times).
// TODO use impl
pub fn new_perlin_noise_1d(seed: i32, amp: f64, freq: f64, octaves: usize) -> Box<Noise<f64, Out=f64> + 'static> {
	let mut noises = Vec::with_capacity(octaves);

	let mut factor = 1.0;
	let mut current_seed = seed;
	for _ in 0..octaves {
		noises.push(new_noise_1d(current_seed, amp / factor, freq * factor));
		factor *= 2.0;
		current_seed *= seed;
	}

	Box::new(CombinedNoise::new(noises, |a: f64, b: f64| { a + b }))
}

/// Generates coherent two-dimensional Perlin Noise.
// TODO use impl
pub fn new_perlin_noise_2d(seed: i32, amp: f64, freq: f64, octaves: usize) -> Box<Noise<(f64, f64), Out=f64> + 'static> {
    let mut noises = Vec::with_capacity(octaves);

    let mut factor = 1.0;
    let mut current_seed = seed;
    for _ in 0..octaves {
        noises.push(new_noise_2d(current_seed, amp / factor, freq * factor));
        factor *= 2.0;
        current_seed *= seed;
    }

    Box::new(CombinedNoise::new(noises, |a: f64, b: f64| { a + b }))
}

/// Generates random (white) noise in the given bounds (both ends inclusive).
// TODO use impl
pub fn new_white_noise(seed: i32, min: f64, max: f64) -> Box<Noise<i32, Out=f64> + 'static> {
    assert!(min <= max);
    Box::new(
        OutputOp::new(
            DefaultI32Noise::new(seed),
            move |f: f64| { f.abs() * (max - min) + min }
        )
    )
}

#[cfg(test)]
mod test {
    use super::*;
    use test::{Bencher, black_box};
    use interpolate::{LinearInterpolator, PerlinInterpolator, CosInterpolator};

    #[bench]
    fn noise_1d_linear_bench_1000values(b: &mut Bencher) {
        b.iter(|| {
            let noise = new_noise_1d_int(0, 1.0, 0.05, LinearInterpolator);
            let mut f = 0.0;
            for _ in 0..1000 {
                black_box(noise.value(f));
                f += 0.33333;
            }
        });
    }

    #[bench]
    fn noise_1d_perlin_bench_1000values(b: &mut Bencher) {
        b.iter(|| {
            let noise = new_noise_1d_int(0, 1.0, 0.05, PerlinInterpolator);
            let mut f = 0.0;
            for _ in 0..1000 {
                black_box(noise.value(f));
                f += 0.33333;
            }
        });
    }

    #[bench]
    fn noise_1d_cos_bench_1000values(b: &mut Bencher) {
        b.iter(|| {
            let noise = new_noise_1d_int(0, 1.0, 0.05, CosInterpolator);
            let mut f = 0.0;
            for _ in 0..1000 {
                black_box(noise.value(f));
                f += 0.33333;
            }
        });
    }

    #[bench]
    fn noise_2d_bench_1000values(b: &mut Bencher) {
        b.iter(|| {
            let noise = new_noise_2d(0, 1.0, 0.05);
            let mut f = 0.0;
            let mut g = 0.0;
            for _ in 0..1000 {
                black_box(noise.value((f, g)));
                f += 0.1343;
                g += 0.5644;
            }
        });
    }
}
